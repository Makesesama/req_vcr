defmodule Reqord.Case do
  @moduledoc """
  ExUnit case template for using Reqord in tests.

  This module provides automatic cassette management and Req.Test integration
  for your tests.

  ## Usage

      defmodule MyAppTest do
        use Reqord.Case

        test "makes API call" do
          # Requests will automatically use cassettes
          {:ok, resp} = Req.get("https://api.example.com/data")
          assert resp.status == 200
        end

        @tag vcr: "custom/cassette/name"
        test "with custom cassette name" do
          # Will use custom cassette name instead of auto-generated
        end

        @tag req_stub_name: MyApp.CustomStub
        test "with custom stub name" do
          # Will use custom Req.Test stub name
        end
      end

  ## Configuration

  Set the VCR record mode via the `REQORD` environment variable or application config.

  ### Environment Variable

  - `REQORD=once` - Strict replay, raise on new requests
  - `REQORD=new_episodes` - Replay existing, record new requests
  - `REQORD=all` - Always hit live network and re-record
  - `REQORD=none` - Never record, never hit network (default)

  ### Application Config

  You can also configure the default mode in your config files:

      config :reqord, default_mode: :none

  ### Per-Test Mode

  Override mode for specific tests using tags:

      @tag vcr_mode: :new_episodes
      test "allows new recordings" do
        # This test will record new requests
      end

  ### Per-Test Matchers

  Override matchers for specific tests:

      @tag match_on: [:method, :path, :body]
      test "matches on method, path, and body" do
        # This test uses custom matchers
      end

  ## Cassette Naming

  Reqord supports multiple ways to organize your cassettes, with the following priority:

  ### 1. Explicit Path (`:vcr_path` tag)

  Use the `:vcr_path` tag to explicitly set the cassette path:

      @tag vcr_path: "providers/google/gemini-2.0-flash/basic_chat"
      test "basic chat" do
        # Uses "providers/google/gemini-2.0-flash/basic_chat.jsonl"
      end

  ### 2. Named Builders (Recommended)

  Define reusable builders in config and reference them by name:

      # config/test.exs
      config :reqord,
        cassette_path_builders: %{
          llm_provider: fn context ->
            provider = get_in(context, [:macro_context, :provider]) || "default"
            model = get_in(context, [:macro_context, :model]) || "default"
            "providers/\#{provider}/\#{model}/\#{context.test}"
          end,
          api: fn context -> "api/\#{context.test}" end
        }

  Then use them in test modules:

      defmodule MyApp.LLMTest do
        use Reqord.Case, cassette_path_builder: :llm_provider
        # Cassettes: providers/google/gemini-flash/test_name.jsonl
      end

      defmodule MyApp.APITest do
        use Reqord.Case, cassette_path_builder: :api
        # Cassettes: api/test_name.jsonl
      end

      defmodule MyApp.UtilsTest do
        use Reqord.Case
        # Cassettes: Utils/test_name.jsonl (default)
      end

  ### 3. Global Path Builder

  Configure a single builder for all tests:

      config :reqord,
        cassette_path_builder: fn context ->
          provider = context[:provider] || "default"
          "\#{provider}/\#{context.test}"
        end

  ### 4. Simple Name Override (`:vcr` tag)

  Override with a simple name using the `:vcr` tag:

      @tag vcr: "my_custom_cassette"
      test "example" do
        # Uses "my_custom_cassette.jsonl"
      end

  ### 5. Default Behavior

  By default, cassettes are named after the test module and test name:
  `"ModuleName/test_name.jsonl"`

  ## Macro-Generated Tests

  For tests generated by macros that need to access compile-time variables
  for cassette naming, use `set_cassette_context/1` with named builders:

      # config/test.exs
      config :reqord,
        cassette_path_builders: %{
          llm_provider: fn context ->
            provider = get_in(context, [:macro_context, :provider]) || "default"
            model = get_in(context, [:macro_context, :model]) || "default"
            "providers/\#{provider}/\#{model}/\#{context.test}"
          end
        }

      defmodule MyLLMTest do
        use Reqord.Case, cassette_path_builder: :llm_provider

        for {provider, models} <- [{"google", ["gemini-flash"]}, {"openai", ["gpt-4"]}] do
          @provider provider
          for model <- models do
            @model model

            describe "\#{provider}:\#{model}" do
              setup do
                # Provide macro context for cassette naming
                Reqord.Case.set_cassette_context(%{
                  provider: @provider,
                  model: @model
                })
                :ok
              end

              test "generates text" do
                # Each provider/model gets its own cassette:
                # providers/google/gemini-flash/test_generates_text.jsonl
                # providers/openai/gpt-4/test_generates_text.jsonl
              end
            end
          end
        end
      end

  See [MACRO_SUPPORT.md](../../docs/MACRO_SUPPORT.md) for detailed examples.

  ## Spawned Processes

  If your test spawns processes that make HTTP requests, you need to allow them:

      test "with spawned process" do
        task = Task.async(fn ->
          Req.get("https://api.example.com/data")
        end)

        Reqord.allow(MyApp.ReqStub, self(), task.pid)
        Task.await(task)
      end
  """

  defmacro __using__(opts) do
    quote bind_quoted: [opts: opts] do
      use ExUnit.Case, Keyword.drop(opts, [:cassette_path_builder])
      import Reqord.RedactCassette

      # Store the named builder from use options
      @cassette_path_builder_name opts[:cassette_path_builder]

      setup context do
        # Merge macro context if it exists
        macro_context = Reqord.CassetteState.get_context(self())

        context =
          if map_size(macro_context) > 0 do
            # Add macro_context to the context map for use by path builder
            Map.put(context, :macro_context, macro_context)
          else
            context
          end

        # Add module-level named builder to context
        context =
          if @cassette_path_builder_name do
            Map.put(context, :named_builder, @cassette_path_builder_name)
          else
            context
          end

        stub_name = context[:req_stub_name] || default_stub_name()
        mode = vcr_mode(context)
        cassette_name = cassette_name(context)
        match_on = context[:match_on] || Application.get_env(:reqord, :match_on, [:method, :uri])

        Req.Test.set_req_test_to_private()
        Req.Test.set_req_test_from_context(context)

        Reqord.install!(
          name: stub_name,
          cassette: cassette_name,
          mode: mode,
          match_on: match_on
        )

        ExUnit.Callbacks.on_exit(fn ->
          Reqord.cleanup(cassette_name, mode)
          # Clean up macro context
          Reqord.CassetteState.clear_context(self())
        end)

        Req.Test.verify_on_exit!(context)

        :ok
      end

      defp default_stub_name do
        module_name = __MODULE__ |> Module.split() |> List.first()
        Module.concat([module_name, "ReqStub"])
      end

      defp vcr_mode(context) do
        cond do
          context[:vcr_mode] || context[:integration_mode] ->
            context[:vcr_mode] || context[:integration_mode]

          env_mode = System.get_env("REQORD") ->
            parse_mode(env_mode)

          app_mode = Application.get_env(:reqord, :default_mode) ->
            app_mode

          true ->
            :none
        end
      end

      defp parse_mode(mode_str) do
        case String.downcase(mode_str) do
          "once" -> :once
          "new_episodes" -> :new_episodes
          "all" -> :all
          "none" -> :none
          _ -> :none
        end
      end

      defp cassette_name(context) do
        cond do
          # 1. Explicit path via :vcr_path tag (highest priority)
          path = context[:vcr_path] ->
            path

          # 2. Per-test path builder via tag
          is_function(context[:cassette_path_builder], 1) ->
            context[:cassette_path_builder].(context)

          # 3. Named builder from module use options
          context[:named_builder] ->
            builder_name = context[:named_builder]
            builders = Application.get_env(:reqord, :cassette_path_builders, %{})

            case Map.get(builders, builder_name) do
              nil ->
                raise ArgumentError,
                      "Named cassette path builder :#{builder_name} not found. " <>
                        "Available builders: #{inspect(Map.keys(builders))}"

              builder when is_function(builder, 1) ->
                builder.(context)

              _ ->
                raise ArgumentError,
                      "Cassette path builder :#{builder_name} must be a function that takes a context"
            end

          # 4. Global path builder from config
          not is_nil(Application.get_env(:reqord, :cassette_path_builder)) ->
            Application.get_env(:reqord, :cassette_path_builder).(context)

          # 5. Simple name override via :vcr tag (backwards compatibility)
          true ->
            case context[:vcr] || context[:integration] do
              name when is_binary(name) ->
                name

              _ ->
                # 6. Default behavior - auto-generate from module and test name
                module_name =
                  __MODULE__
                  |> Module.split()
                  |> List.last()
                  |> String.replace(~r/Test$/, "")

                test_name =
                  context.test
                  |> Atom.to_string()
                  |> String.replace(~r/^test /, "")
                  |> String.replace(~r/\s+/, "_")

                "#{module_name}/#{test_name}"
            end
        end
      end

      defoverridable default_stub_name: 0
    end
  end

  @doc """
  Sets cassette context for the current test process.

  This is useful for macro-generated tests where compile-time variables
  (like module attributes) need to be included in cassette naming.

  The context map will be merged with test tags and made available to
  the `:cassette_path_builder` function.

  ## Examples

      # In a macro-generated test
      for model <- ["gpt-4", "gemini-flash"] do
        @model model

        describe "\#{model}" do
          setup do
            Reqord.Case.set_cassette_context(%{model: @model})
            :ok
          end

          test "example" do
            # Cassette naming can now access the model
          end
        end
      end

  ## Usage with cassette_path_builder

      # config/test.exs
      config :reqord,
        cassette_path_builder: fn context ->
          # context.macro_context contains the data from set_cassette_context
          model = context.macro_context[:model] || "default"
          "\#{model}/\#{context.test}"
        end

  """
  @spec set_cassette_context(map()) :: :ok
  def set_cassette_context(context) when is_map(context) do
    Reqord.CassetteState.put_context(self(), context)
  end
end
